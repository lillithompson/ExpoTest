# App State Overview

This document is the single source of truth for reconstructing the app from scratch. It describes routes, screens, modals, UI rules, and the behavior and data flow of the tile system.

**Structure**

Root Layout (app/_layout.tsx)
- Mobile web banner is not shown. The component and hooks (`getIsMobileWebForWindow`, `useIsMobileWeb`, `MobileWebBanner`) remain in the codebase but are not rendered in the layout.
- On **mobile web** and **iOS** only: an iOS-style bottom tab bar (components/mobile-tab-bar.tsx) is shown when the current route is `/` or `/tileSetCreator` and no overlay is open. It has two tabs: "Files" (navigates to `/`) and "Tile Sets" (navigates to `/tileSetCreator`). The tab bar is hidden on editor, modifyTile, manual, and modal; it is also hidden when the Settings overlay (or any overlay signaled via setHideTabBarOverOverlay) is open on the Files or Tile Set Creator views so it does not render over modals. Desktop web and Android use the existing header-based navigation (tap "File" or "Tile Sets" in the header to switch). Tab bar visibility is provided via TabBarVisibleProvider (tabBarVisible, hideTabBarOverModify, hideTabBarOverOverlay); File and Tile Set Creator list screens add bottom padding (TAB_BAR_HEIGHT + safe area bottom) when the tab bar is visible so content is not obscured.

Main Routes
- `/` (app/index.tsx): File and Modify modes in one screen, controlled by `viewMode`.
- `/manual` (app/manual.tsx): In-app user manual (views, tools, settings). Linked as the first option in Settings (File and Modify views).
- `/tileSetCreator` (app/tileSetCreator/index.tsx): Tile Set list and management.
- `/tileSetCreator/editor` (app/tileSetCreator/editor.tsx): Tile Set details and tile list.
- `/tileSetCreator/modifyTile` (app/tileSetCreator/modifyTile.tsx): Tile editor for a single tile template.
- `/modal` (app/modal.tsx): Example modal route, not used by core flows.

File View (viewMode = "file")
- Status bar background strip at the top (white).
- Header row: On desktop web, switchable tabs "Files" | "Tile Sets" (components/desktop-nav-tabs.tsx); active tab is highlighted with underline; inactive tab navigates on press. On mobile web and native, single title "Files" (press navigates to Tile Set Creator). Actions on the right.
- Header actions: Import .tile (upload icon), New File (plus), Select Mode (checkbox), Settings (cog). Import opens a file picker (web: hidden input accept .tile; native: DocumentPicker) and loads the .tile file as a new canvas (then opens Modify view).
- Select mode bar: Animated bar with Delete button (left), selected count (center), Exit (right).
- File grid: Scrollable list of file cards, sorted by `updatedAt` descending. Column count is computed from content width so as many columns as fit: on desktop web (width ≥ 768) at least FILE_GRID_MIN_CARD_WIDTH_DESKTOP_WEB (240px) per card for larger thumbnails; otherwise FILE_GRID_MIN_CARD_WIDTH (100px). Cards pack to the upper left with no extra horizontal spread. On web, file thumbnail display size is capped (aspect ratio preserved): FILE_THUMB_DISPLAY_SIZE (200 px) on narrow viewports, 400 px (2×) on desktop (content width ≥ 768). Generated thumbnail resolution is FILE_THUMB_SIZE 400 (2× display for sharp thumbnails on desktop); native ViewShot and web renderTileCanvasToDataUrl use 400. Cards show previews (thumbnail/preview if available, otherwise live tile grid on native; web uses placeholder).
- File card interactions: Tap opens Modify view; long press opens File Options menu.
- File Options menu: Download (web direct or native overlay), Download SVG (web only), Download .tile (serializes canvas to custom .tile format and downloads or shares), Duplicate, Delete.
- New File modal: On desktop web, title "Preferred Tile Size"; on iOS and mobile (web), title "New File Size" (header unchanged). On iOS and mobile web, resolution options are S, M, L (tile sizes 100, 50, 25 px). On desktop web and Android, tile size selection grid is [25, 50, 75, 100, 150, 200].
- Settings overlay (file view): First option "View manual" opens the in-app manual (app/manual.tsx). Then Show Debug toggle, background color picker, background line color picker, background line width slider. Bottom of settings: light grey platform label (Desktop Web, Mobile Web, Expo Go, iOS, or Android). "Delete all local data" button: shows an "are you sure" confirmation (Alert on native, window.confirm on web); on confirm, clears AsyncStorage for files, tile sets, bakes, favorites, patterns, and settings, resets settings to defaults (setSettings(getDefaultSettings())), resets in-memory state via clearAllFiles, reloadTileSets, clearBrushFavorites, and clearAllPatterns, then closes settings and returns to file view.

Modify View (viewMode = "modify")
- Status bar background strip at the top (white).
- Header row: Back button "< Modify" (returns to File view immediately; save runs in background) and toolbar actions.
- Toolbar actions (left to right): Lock region (first, when a selection exists), Undo, Redo, Selection tool, Reset (Clear), Flood (tap) / Flood Complete (long press), Reconcile (tap) / Controlled Randomize (long press), Mirror (single cycling button). Mirror cycles: no mirroring (grey horizontal icon) → horizontal → horizontal + vertical (arrow-all icon) → vertical → no mirroring. Icon is blue (#3b82f6, same as mirror lines) when any mirroring is on; icon reflects current state (flip-horizontal for none/horizontal, flip-vertical for vertical, arrow-all for both). Undo and Redo are disabled when there is nothing to undo or redo. When a region is selected, the Lock button appears: tap to lock the selected region (tiles in it cannot be modified by any tool) or, if the selection exactly matches an existing locked region, to unlock it. Multiple locked regions are allowed but they cannot overlap. Locked regions are persisted with the file.
- Undo/Redo: All edits to the tile canvas (brush strokes, flood, reset, reconcile, controlled randomize, selection clear) are recorded. A single drag (pointer or touch stroke) is one undo step: the state before the drag is pushed once at drag start, and all cells painted during the drag are restored by one undo. Undo restores the previous state; redo re-applies an undone change. History is cleared when loading a file or tile (loadTiles). Maximum 50 undo steps per canvas. On mobile web, two-finger tap on the canvas invokes undo and three-finger tap invokes redo (when no fingers moved during the gesture). Single-finger paint is never committed on touch start; it is only committed on touchmove (drag) or touchend (tap). On touchmove, commit requires both 180ms delay and at least 8px movement so jitter while the second finger lands never paints; then touchend correctly triggers undo only. Consecutive identical undo snapshots are not pushed. When undoing or redoing, steps that would leave the canvas unchanged are skipped automatically, so every undo/redo that runs visibly changes the canvas.
- Selection tool: Toggle in toolbar; when active it is green (#22c55e) like the mirror toggles. When Selection is on, tapping or dragging on the tile canvas draws a rectangular selection box; when the drag ends the selection stays. A single tap (no drag) clears the selection. Double-click (or double-tap) anywhere on the tile canvas exits selection mode and clears the selection. Toggling the Selection button off clears the selection and hides the overlay. Clear (Reset), Flood, Flood Complete, Reconcile, and Controlled Randomize apply only to the selected region when a selection exists (and never modify locked cells). Changing tools in the brush palette does not exit selection mode. When selection mode is on and a selection exists, selecting a tool in the tile palette (fixed, pattern, random, etc.) triggers a flood fill with that tool over the selection. Single tap on a locked region (even when not in selection mode) enters selection mode and selects that locked region, and the Lock button appears so the user can unlock it if desired.
- Locked tiles: Lock state is per tile (per cell index). Locked tiles cannot be modified by any tool (brush, flood, reset, reconcile, etc.) and are drawn at 0.5 opacity. A red (#dc2626) border is drawn only along the outside edge of the locked region (the boundary between locked and unlocked cells). When a selection exists, the Lock button appears as the first toolbar item: tap to lock all tiles in the selection or unlock all tiles in the selection (toggle). If every tile in the selection is already locked, the button is green (active); otherwise it is grey. Single tap on a locked tile enters selection mode and selects that cell so the user can unlock it. On file load, all tiles are unlocked (lockedCells is cleared and persisted) and selection mode is cleared (selection tool off, canvas selection cleared).
- Canvas frame: Grid background, optional mirror guide lines, optional preview image during hydration.
- Tile grid: Web renders TileCell components; mouse and touch are both supported so that tap and drag work on desktop and mobile browsers (e.g. Safari on iOS). Touch handlers use the capture phase (onTouchStartCapture, onTouchMoveCapture, onTouchEndCapture, onTouchCancelCapture) so that drag-to-paint works when the gesture starts on an initialized tile (whose image would otherwise be the touch target and prevent the grid from receiving touchmove). Native renders a single Skia canvas (TileGridCanvas) for all tiles.
- Pattern creation overlays: Top and bottom overlays shown while in pattern creation mode.
- Brush panel: Scrollable tile palette (2–5 rows; when row height would exceed 120px another row is added) plus Random, Draw, Clone, Erase, and Pattern buttons. Random, Draw, Erase, Clone, and Pattern (when no pattern selected) show a centered icon above smaller, unbold label text. The Pattern button shows the same icon+label style when no pattern is selected; when a pattern is selected it shows the pattern thumbnail. Palette tiles use an absolutely positioned 4px border overlay (dark when unselected, green when selected) and a full-size (itemSize × itemSize) content wrapper so tile images stay centered with no shift on selection or when switching from cached/loading image to atlas canvas.
- Pattern chooser modal: Lists patterns for the active category with actions for create and select mode.
- Pattern save modal: Preview of the selection with Save/Cancel.
- Tile Set chooser overlay: Grid of thumbnails with name below. Built-in categories: if the directory in assets/images/tiles contains thumbnail.svg, that is used as the category thumbnail (and is not a tile option); otherwise the first tile in the set is used. User tile sets: alphabetically first tile per set. At top: Allow Border Connections toggle. Built-in categories then user tile sets. Selected items are brighter with green border (#22c55e, 2px); multi-select to define the active palette.
- Settings overlay (modify view): First option "View manual" opens the in-app manual. Then Download PNG action, Show Debug toggle, background color and line controls. Bottom of settings: light grey platform label (Desktop Web, Mobile Web, Expo Go, iOS, or Android).
- Download overlay (native): ViewShot capture with background toggle and PNG/SVG actions.

Tile Set Creator List (tileSetCreator/index.tsx)
- Header row: On desktop web, same switchable tabs "Files" | "Tile Sets" as File view; on mobile web and native, single title "Tile Sets" (tap returns to File view). Actions for Create and Select Mode.
- Select mode bar: Animated bar with Delete, selected count, Exit.
- Tile set grid: Cards with 2x2 previews (baked image or, on native, live grid). The thumbnail uses the four tiles that are alphabetically first by name in the set (same order in Tile Set chooser). On web, a dark placeholder is shown until the baked preview is ready (no live grid) to avoid a white-border flash; baked previews are cached in a module-level map so they persist across navigations and are not regenerated when returning to the list. Long press (web only) opens download modal.
- Create Tile Set modal: Name input and resolution options 2, 3, 4.
- Download Tile Set modal (web only): Downloads all tiles in the set as a ZIP of SVGs. Each SVG is named `{tile set name}_{connectivity}.svg` (spaces in the tile set name become underscores). If multiple tiles share the same connectivity, they are named `{tile set name}_01_{connectivity}.svg`, `{tile set name}_02_{connectivity}.svg`, etc.

Tile Set Editor (tileSetCreator/editor.tsx)
- Header row: Back, tile set name, actions for Add Tile, Select Mode, and Settings.
- Select mode bar: Animated bar with Delete, selected count, Exit.
- Tile grid: Cards with thumbnails or live previews.
- Context menu (web only): Duplicate, Download SVG, Delete, Cancel.
- Settings overlay: Rename tile set.

Tile Modify View (tileSetCreator/modifyTile.tsx)
- Header row: back button label "Modify Tile" (upper left); toolbar actions similar to Modify View (Undo, Redo, Clear, Fill, Mirror cycling button).
- Grid background and optional debug overlay.
- Brush panel: 2–5 rows (row count increases when row height would exceed 120px); for editing the tile template.
- Tile Set chooser (double tap or long press Random): Same thumbnail grid styling as the File/Modify view Tile Set chooser (card, 72×72 thumb; built-in category uses thumbnail.svg when present, else first tile; green border when selected). Only built-in categories are shown; UGC tile sets are not selectable in this modal.

Built-in tile sets (assets/images/tiles)
- The manifest is generated by scripts/generate-tiles-manifest.js. Each subdirectory is a category; image files (png, jpg, jpeg, webp, svg) are tile options. A file named thumbnail.svg in a directory is used only as that category’s thumbnail in the Tile Set chooser and is excluded from TILE_MANIFEST (not offered as a tile option).

Core Behaviors and Tool Rules
- Tile connectivity is driven by `tile_########.png/svg` naming (see AI_ASSET_RULES). Connections are used to validate random placements and compatibility.
- Allow Border Connections: When off, edges behave as if neighbors are empty and connections cannot extend past the grid.
- Random brush tap (single-tile only): Attempts to place a compatible tile at the tapped cell. When Allow Border Connections is off and the cell has at least one adjacent initialized tile, uninitialized (empty) neighbors are treated as 00000000 connections for both candidate selection and validation; when the cell has zero adjacent tiles, behavior is unchanged. Flood fill and Reconcile are not affected. If no legal placement is found and legal placement is required, the tap does nothing. Otherwise an error tile is placed.
- Random brush double tap: Opens the Tile Set chooser.
- Random brush long press: Opens the Tile Set chooser.
- Draw brush: Starting a draw action always overwrites the cell(s) where the stroke begins; preexisting tiles do not affect placement (first tile and first tile of a new stroke on a non-adjacent cell are validated as if all cells were empty). Stroke order is tracked (ordered list of cell indices). When adding tile n, only n-1 is updated (to connect to n-2 and n); tiles further back are unchanged. First tile placed has exactly one connection. When the second tile is placed: first update the first tile to have exactly one connection (to the second), then place the second tile with one connection to the first and exactly one more (two connections total). Nth tile (n ≥ 2) is chosen from variants that have exactly two connections, one in the direction toward n-1. n-1 is updated from variants that have true exactly in the directions toward n and n-2 (getCandidatesWithExactConnections). Tile selection treats all tiles not in the current stroke as 00000000. A stroke is valid iff, when checking tiles in order, each tile has connections to exactly and only its stroke neighbors (the previous and next cell in the stroke). The first tile must have exactly one connection (one “outgoing”); every other tile must have true exactly in the directions toward its stroke neighbors and false elsewhere. First tile: candidates filtered to exactly one connection. Subsequent tile: must have exactly two connections, one in the direction toward the previous tile; candidates from compatible placements are filtered accordingly. When updating the previous (n-1th) tile after placing the nth, the replacement is chosen from variants that have true exactly in the directions toward nth and n-2th (and false in all other directions); if no such variant exists, the placement is rejected. After applying the new tile and the n-1 update, the stroke is validated (isStrokeValid); if invalid, the placement is rejected. Stroke is cleared when the pointer/touch ends. When a stroke ends (pointer/touch release or internal gap from a non-adjacent move), the stroke is finalized: if length 1, that cell is set to a 00000000 tile (no connections, or empty); if length ≥ 2, the last tile is replaced with a variant that has exactly one connection (toward the n−1th tile). If during a continuous drag the user moves to a cell not adjacent to the previous stroke cell (e.g. moving too fast), that cell is treated as the first tile of a new stroke: the previous stroke is finalized, then a one-connection tile is placed there and the stroke restarts from that cell, so one continuous user action can produce multiple logical strokes. Flood and Flood Complete with Draw use the same logic as Random.
- Fixed brush tap: Places the selected tile with current rotation/mirror and mirrors to linked cells when mirror toggles are enabled.
- Fixed brush double tap (palette): Cycles rotation three times, then mirror X, then mirror Y. Horizontal and vertical mirrors are in rotation-0 space: they always flip the tile along its original left-right (horizontal) or top-bottom (vertical) axis, regardless of current rotation.
- Fixed brush long press (palette): Opens Favorites dialog to add/remove the tile with a color tag. Dialog title: "Favorite Tile?" or "Unfavorite Tile?"; color swatches and Cancel / Remove (or Favorite) actions. When the tile is already favorited, changing the favorite color is saved immediately (so canceling the unfavorite keeps the new color). Favorites in the palette are sorted by color: red, orange, green, blue, purple, white; changing a favorite's color updates the sort order.
- Erase brush: Tap clears a tile. Flood clears all tiles.
- Clone brush: First tap sets clone source. Drag paints clones relative to the anchor cell. Long press on canvas resets clone source to the pressed cell. Clone wraps around grid edges. On mobile web (e.g. iOS Safari), synthesized mouse events after a touch are ignored so one tap does not set both source and anchor; only the touch is handled.
- Pattern brush: Uses a pattern anchor cell to map pattern tiles by offset. Pattern mirrors can be toggled in the pattern picker. Pattern rotation is 90-degree increments. Pattern brush long press/double tap opens the pattern picker.
- Pattern creation: Drag-select in the grid to define a pattern. Save dialog prompts to store it in category storage.
- Flood (tap): Fills all cells based on brush mode (random, draw, fixed, pattern, erase). Respects mirror toggles. With the random brush, Flood replaces every non-locked tile with a new random tile (full overwrite); locked tiles are unchanged. With the draw brush, flood fill uses spiral order: the effect is as if the draw stroke started at the upper-left and spiraled inward (right to border, down to border, up to border−1, right to border−1, etc.). When a region is selected, the selection’s bounding rectangle is treated as the canvas for the spiral (same rule, with selection edges as borders). With the random brush and a selection, the selected region is cleared first then randomized (same as full-canvas random flood), so it behaves like Flood, not Flood Complete.
- Flood Complete (long press): Fills only empty cells. When mirrors are enabled, it treats mirrors as a unit and expands driven indices if any mirrored target is filled. On mobile web, a synthesized tap after long press is ignored (via floodLongPressHandledRef) so Flood (full fill) does not run after Flood Complete.
- Clear (Reset): Full-canvas Clear resets all tiles to empty except locked tiles, which are preserved. Selection Clear clears only non-locked cells in the selection.
- Reconcile (tap): Iteratively replaces invalid tiles with compatible candidates to reduce invalid connections. Tiles are visited in placement order (oldest placed first). So if you draw a line of strokes on top of an existing design, reconcile alters the previously placed design and preserves your latest strokes. Each tile has an optional placedOrder (monotonic counter set when placed); tiles without it (e.g. loaded from file) are treated as oldest. Uninitialized (empty) tiles are never changed; edges to uninitialized neighbors are treated as 00000000 connectivity when validating and picking replacements.
- Controlled Randomize (long press): Replaces tiles with connection-compatible equivalents based on their current connection signature.

**UI**

Visual Rules
- Color scheme: On web (including mobile web), the app always uses light mode colors and does not follow the device dark-mode setting; this avoids incorrect colors when the phone is in dark mode. The web-specific hook `use-color-scheme.web.ts` returns `'light'`; native uses `use-color-scheme.ts` which also returns `'light'`. For web, the root HTML (`app/+html.tsx`) sets `<meta name="color-scheme" content="light" />` and the root layout sets `document.documentElement.style.colorScheme = 'light'` so the browser applies light styling to the page and dialogs (e.g. New File modal on mobile web).
- Backgrounds: Main screen background is dark gray (#3f3f3f). File and Tile Set list headers are near-black (#202125). Tile Set editor uses a light header (#E2E3E9).
- Panels and overlays: Modal panels are white with dark borders (#1f1f1f). Backdrops are translucent black (rgba(0,0,0,0.7)).
- Highlights: Selection and active states use green (#22c55e). Destructive actions use red (#dc2626).
- Grid visuals: Grid background and line colors are configurable. Line width is configurable. Mirror guides appear as thin lines over the grid.
- Typography: Uses ThemedText variants for title, default, and semi-bold text. All main labels are uppercase or title case, not icon-only.
- Icons: MaterialCommunityIcons for toolbar and header actions.
- Cards and thumbnails: Dark frames with borders; selection adds a green border and thicker stroke.

Layout Rules
- On mobile web and iOS, the bottom tab bar has min height 48 plus safe area inset; File and Tile Set Creator list screens add matching bottom padding when the tab bar is visible.
- Headers are fixed height (50). Tool buttons are square (40). Brush panel height is 160 with 1px row gaps.
- File grids are 3 columns on mobile with side padding (12) and gaps (12).
- Tile palette uses 2–5 rows; when the height of a row would exceed 120px, another row is added so each row stays at or below 120px. On desktop web, the brush panel reserves space for the horizontal scrollbar (WEB_SCROLLBAR_HEIGHT) so the bottom row is not cut off; on mobile web this space is not reserved. On mobile web, content width uses the visual viewport and the brush panel is constrained to 100% width with minWidth: 0 so the palette is not laid out with an incorrect width (e.g. half-scrolled off screen). The palette content uses justifyContent: 'flex-start' on web so the left edge of the tile palette aligns with the left edge of the screen.
- Tile canvas layout is capped at 512 cells: `computeGridLayout` and `computeFixedGridLayout` (utils/tile-grid.ts) never return a grid with more than 512 tiles; when capping is needed, dimensions are chosen to be as square as possible (e.g. 22×23). The hook (use-tile-grid) also clamps `totalCells` to this limit.

**Infrastructure**

Persistence and Storage
- Files stored in AsyncStorage key `tile-files-v1` and active file id in `tile-files-active-v1`.
- Settings stored in AsyncStorage key `tile-settings-v1` (mirror toggles, border rules, background colors, line width, tile set selections).
- Patterns stored in AsyncStorage key `tile-patterns-v1`.
- Tile sets stored in AsyncStorage key `tile-sets-v1`; baked tile sources cached in `tile-sets-bakes-v1`.
- Brush favorites stored in AsyncStorage key `tile-brush-favorites-v1`.
- Delete all local data (File > Settings): `utils/clear-local-data.ts` clears the above storage keys (including tile-patterns-v1 and tile-settings-v1); app then resets settings to defaults (setSettings(getDefaultSettings())), resets files (useTileFiles.clearAllFiles), tile sets (useTileSets.reloadTileSets), favorites (clearBrushFavorites from tile-brush-panel), and patterns (useTilePatterns.clearAllPatterns).
- File hydration sanitizes stored data: `tiles` is coerced to an array and `grid` requires numeric `rows`/`columns`, otherwise defaults are applied.

File Data Model
- Each file stores: id, name, tiles array, grid rows/columns, category and categories, tileSetIds, sourceNames, preferredTileSize, lineWidth, lineColor, thumbnailUri, previewUri, updatedAt, lockedCells (optional array of cell indices that cannot be modified).
- .tile format: Custom export/import format (extension .tile). utils/tile-format.ts defines versioned JSON: serializeTileFile(file) and deserializeTileFile(json). Import (File toolbar) loads a .tile file as a new canvas; Download .tile (file long-press menu) saves the canvas to a .tile file (web: blob download; native: share from cache).
- Tile placement uses `imageIndex`, `rotation`, `mirrorX`, `mirrorY`. Empty tiles are `imageIndex = -1`; error tiles are `imageIndex = -2`.
- Tiles can also carry a `name` for the original tile source; rendering prefers `name` to avoid index drift when tile set sources change.

Autosave and Preview Pipeline
- Autosave is debounced (150ms). Web preview capture is additionally delayed (800ms).
- On native, saving uses ViewShot capture and writes PNGs to cache `tile-previews/` for full preview and thumbnail.
- On web, previews and thumbnails are generated via `renderTileCanvasToDataUrl`.
- Leaving Modify view starts a full save via `persistActiveFileNow` in the background (navigation is immediate).

Hydration and Rendering
- File changes run through a hydrate pipeline that suspends rendering and uses `loadToken`/`loadedToken` gating.
- During hydration, preview images are shown and can overlay the grid until tiles are applied, referenced user tile sets are baked, tile/source updates have been stable briefly, and the grid has stabilized (double RAF), preventing interim `tile_error` flashes.

Tile Source Mapping
- Active palette sources are built from selected categories plus baked user tile sets.
- Each file stores `sourceNames` so tile indices remain stable even if available sources change.
- File source resolution uses an "effective" source list: the active file's `sourceNames` unless the local `fileSourceNames` contains new entries (e.g., freshly added UGC tiles), in which case the local list is used to render immediately.
- If a file has no `sourceNames`, it is seeded from the current selection and stored back into the file.
- When palette sources expand, `sourceNames` are extended and persisted.
- File source initialization is guarded to run once per active file id and can defer until baked tile sets are ready.
- When a file references user tile sets (via `tileSetIds`) but baked sources are not ready yet, source seeding is deferred to avoid remapping tiles to the wrong sources.
- Palette selection maps tiles to file indices by tile name (not palette position) so adding/removing tile sets does not shift existing mappings.
- Fixed brush carries the selected source `sourceName`; placement in useTileGrid resolves index by name when `sourceName` is set so the correct UGC tile is placed even when React state (e.g. `fileSourceNames`) updates asynchronously (fixes iOS Expo Go bug where UGC tiles rendered as built-in). The app also passes `getFixedBrushSourceName` (a ref-backed getter) so placement always reads the current selected source name and is not affected by stale closures on tap (Expo Go / React Native).
- Hydration uses the file's own `sourceNames` when present: `pendingRestoreRef` stores `sourceNames` from the file being loaded, and `hydrateTilesWithSourceNames` assigns `tile.name` from that list so rendering (which prefers `tile.name`) shows the correct UGC tile even when `tileSources` order differs on Expo Go (e.g. built-in first).
- Mapping prefers the active file's `sourceNames` when available to keep palette interactions aligned during hydration.
- When a user-generated tile is modified (Tile > Modify), the baked asset gets a new filename (updatedAt/connectivity bits). So that existing design files do not reference a stale name and fail to load, the bake step in use-tile-sets collects old → new baked name pairs and calls `onBakedNamesReplaced`. use-tile-files exposes `replaceTileSourceNames(replacements)`, which updates every file's `tiles[].name` and `sourceNames` to use the new names, then persists. The main File view and the Modify Tile screen both pass this callback into useTileSets so that edits in either place keep all files in sync.
- After deleting all tiles from a set, a file that had used those tiles can end up with empty `sourceNames` and only error tiles. `areActiveFileSourcesResolved` treats that as resolved when every tile has `imageIndex < 0` (no cell needs a source), so the file can leave the loading state instead of staying on the cached overlay.
- A tile set with 0 tiles (container exists but all tiles deleted) must not block file loading. `areTileSetsReady(ids)` returns true for a set id if that set has at least one baked source OR the set has `tiles.length === 0`. The bake effect clears baked sources for empty sets (`updates[set.id] = []`) so no stale sources remain.
- When a tile set or a single tile is deleted, design files that referenced those baked sources would otherwise break. use-tile-sets calls `onTileSourceNamesRemoved(removedNames, { namePrefix })` before removing the set or tile. use-tile-files exposes `replaceTileSourceNamesWithError(removedNames, options)`, which uses `utils/tile-file-sync.applyRemovedSourcesToFile`: replaces any tile that references a removed source (by `name` or by `imageIndex` into `sourceNames`) with the tile_error tile, remaps remaining tiles to the new `sourceNames` indices so no index is out of bounds, and removes the names from `sourceNames`. Single-tile delete also passes `namePrefix` (e.g. `setId:tileId_`) so references are fixed even when exact baked names are not available. The File view, Modify Tile screen, Tile Set list, and Tile Set editor all pass this callback into useTileSets. Tests in `utils/__tests__/tile-file-sync.test.ts` guard the sequence: tile set with two tiles, file uses both; delete first tile then second — file stays loadable (no out-of-bounds indices, removed cells show error tile).
- Palette order follows the current selection (user tile sets first, then built-in categories). Favorites are sorted to the front of the palette.
- `normalizeTiles` guards against undefined/null tile arrays and falls back to empty tiles for the current grid size.
- On native, user tile names (`tileset-<id>:<file>.svg`) are resolved to a direct file path under `documentDirectory/tile-sets/<setId>/` if the baked source is missing, `tile_error`, or points outside the tile-sets directory.

Tile Set Baking and Caching
- Tile sets are baked into SVGs. Web stores data URIs; native writes files under `documentDirectory/tile-sets/<setId>/`.
- Bake signatures and per-tile signatures prevent redundant work. A memory cache stores SVG XML for reuse during baking.
- While baking on native, placeholder baked sources (with error tiles) can be published early to stabilize source name ordering; these are replaced once SVGs finish writing.
- Baked tile names include the tile `updatedAt` timestamp; legacy baked sources are kept so existing placed tiles keep rendering even if tiles are edited or deleted. The palette only shows current baked names.

SVG Loading and Caching (TileAsset)
- SVG XML is cached in-memory (`svgXmlCache`) by URI. SVG overrides are cached in `svgOverrideCache`.
- SVGs are loaded via `FileSystem.readAsStringAsync` on native and `fetch` on web.
- On native, UGC tile file URIs (file:// and path contains `/tile-sets/`) never use the shared cache: `isUgcTileFileUri` (utils/tile-uri.ts) identifies them; TileAsset skips svgOverrideCache/svgXmlCache read and does not write loaded XML to the cache for these URIs. This prevents wrong-tile display when a cached built-in tile would otherwise be returned for a UGC placement (e.g. on Expo Go).
- TileAtlasSprite keys TileAsset by source URI (`key={sourceUri ?? name}`) so each distinct source gets a fresh instance and no stale cached content is reused when the source changes.
- `prefetchTileAssets` warms the cache for palette and file sources during Modify view.
- In-flight SVG reads are de-duplicated, and XML is cached under both original and resolved URIs.

Skia Rendering (Native)
- Native grid rendering uses a single Skia canvas (components/tile-grid-canvas.native.tsx) to draw all tiles when running in a dev build or standalone app.
- SVG XML is loaded via `getSvgXmlWithOverrides` and parsed to Skia SVGs, then drawn with transforms for rotation and mirroring.
- Clone overlays and debug dots are drawn directly in Skia.
- Skia requires `@shopify/react-native-skia` with peer deps React >= 19 and React Native >= 0.78.
- Expo Go falls back to the React TileCell grid for compatibility.
- Native Skia rendering prefers `tile.name` when present (falling back to `imageIndex`) to avoid visual drift after source list changes.

**Rendering**
- Web: Tile grid is rendered as React components (TileCell per cell). For live editing, TileCell uses PNG atlas sprites (TileAtlasSprite) generated by useTileAtlas; SVGs are used as a fallback while the atlas loads. Pointer events are handled on the grid container. When the tile canvas is narrower than the content area, it is centered horizontally (gridCanvasWebCenter wrapper with width 100% and alignItems center). The same centering is applied on web in the Modify Tile view (tileSetCreator/modifyTile.tsx).
- Native (Expo Go): Falls back to the same React TileCell grid as web for compatibility. TileCell never uses index-based resolution when `tile.name` is set: it uses `resolveSourceForName(tile.name)` then `resolveUgcSourceFromName(tile.name)` for UGC names, so stale `tileSources` order on Expo Go cannot show built-in tiles for UGC placements.
- Native (dev build / standalone): Tile grid is rendered by a single Skia Canvas (TileGridCanvas). Each tile is drawn as an SVG image with transforms applied in Skia. Clone overlays and debug dots are drawn directly on the Canvas. The Canvas is mounted inside a ViewShot container to support preview captures.
- Preview rendering: During file hydration, the grid is hidden and a PNG preview is shown (if available). Preview/thumbnail capture uses ViewShot on native and `renderTileCanvasToDataUrl` on web. On native, the grid preview image uses `expo-image` (not React Native `Image`) so that `file://` URIs from the cache directory display reliably on iOS Expo Go. Each save writes preview/thumb to unique paths (`${fileId}-${timestamp}-full.png` and `-thumb.png`) and deletes the previous file for that document, so the cached image always reflects the latest state (no stale image cache). The modify view delays `gridStabilized` until the tile canvas has painted: on dev/standalone the Skia TileGridCanvas reports `onPaintReady`; on Expo Go a timeout is used (1.8s). Timeouts are 2.5s (Skia) and 1.8s (Expo Go) to avoid a blank canvas while tiles load.
- File list thumbnails: When a file has `thumbnailUri` or `previewUri`, the app shows that cached thumbnail via `TileAsset` (same on all platforms). When there is no cached thumbnail, native shows the live tile grid as fallback.
- UGC file thumbnails (Expo Go iOS): Line width must match built-in tile sets. `strokeScaleByName` (from user tile set resolution) scales stroke for palette and canvas. When showing the fallback grid (no cached thumbnail) on native, each tile uses scaled `strokeWidth` (file.lineWidth * strokeScaleByName); download overlay tiles use scaled strokeWidth as well. Generated file thumbnails (web `renderTileCanvasToDataUrl`) and downloaded PNG (web via `downloadFile`) and SVG (native overlay and web file menu) now pass `strokeScaleByName` so UGC line widths in exports match the main canvas. SVG download (native overlay and web file menu) pre-fills a source XML cache via `buildSourceXmlCache(sources)` before calling `renderTileCanvasToSvg`, so UGC tile SVGs are loaded (data URI decode, file read on native, fetch on web) and inlined in the exported SVG instead of being missing. Tile set creator (modifyTile) thumbnail generation also passes a per-set `strokeScaleByName` (from `tileSet.resolution`) so tile-entry thumbnails use consistent stroke scale. Export (renderTileCanvasToDataUrl and renderTileCanvasToSvg) uses name-based resolution when `tile.name` is set: source and scale are resolved by `tile.name` so UGC tiles get the correct stroke scale in thumbnails even when palette order differs from the file’s source order.

Performance and Interaction
- Touch and mouse inputs track interaction start/end for perf logging.
- Clone and pattern tools use anchors and wrap-around indexing for consistent offsets.
- Mirroring is applied by deriving driven cells and mapping to mirrored targets.
- Tile placement compatibility uses cached connection tables (buildCompatibilityTables) to avoid recomputing connection transforms per brush action.
Testing
- Unit tests for tile resolution and hydration live in `utils/__tests__/tile-grid.test.ts`. They assert: `hydrateTilesWithSourceNames` assigns `tile.name` from the file's sourceNames so UGC index 0 gets the UGC name; `resolveDisplaySource` uses only name-based resolution when `tile.name` is set (never index, so wrong tile cannot show); `getTileSourceIndexByName` resolves by name; `normalizeTiles` preserves `tile.name`. Run with `npm test` (or `npm run test:watch`). Run tests when changing tile-grid utils or UGC/placement/hydration logic.
- Unit tests for UGC URI detection live in `utils/__tests__/tile-uri.test.ts`. They assert: `isUgcTileFileUri` returns false on web; on native it returns true only for file:// URIs whose path contains `/tile-sets/`, so the TileAsset cache-bypass rule is well-defined and regression-safe. Run tests when changing utils/tile-uri.ts or TileAsset cache behavior.
- Unit tests for the cached canvas preview flow live in `utils/__tests__/preview-state.test.ts`. They assert: `getFilePreviewUri` uses `previewUri ?? thumbnailUri` so the correct cached image is used when opening a file; `hasCachedThumbnail` is true only when the file has `thumbnailUri` or `previewUri` (so the file list always shows the cached thumbnail when present—no platform/tiles branching); `hasPreview` and `showPreview` ensure the preview is shown when we have a URI and the live grid is not visible (or we're clearing); `isOwnPreviewUri` restricts delete to URIs under the preview dir; `buildPreviewPath` produces unique paths per save so the image cache shows the latest state. The app uses `utils/preview-state.ts` for this logic. Run tests when changing preview/load behavior or preview path handling.
- Unit tests for draw-stroke validation live in `utils/__tests__/draw-stroke.test.ts`. They assert: when a stroke is done, (1) the first tile has exactly one connection, (2) every other tile has exactly two connections (only toward stroke neighbors); `validateDrawStroke` and direction helpers are covered. The hook uses `utils/draw-stroke.ts` for stroke validation. Run tests when changing draw tool or stroke validation.
- Unit tests for the file load/hydration flow live in `utils/__tests__/load-state.test.ts`. They assert: `canApplyEmptyNewFileRestore` is true for empty new files (rows/cols 0) when `tileSize > 0` so the apply effect can run and the file becomes editable (avoids "cached preview stuck" bugs); `canApplyNonEmptyRestore` covers the non-empty branch; `isLoadComplete` is true only when `loadedToken === loadToken` and `!hydrating` and `loadToken !== 0`, so deferring `setLoadedToken` or `setHydrating` incorrectly leaves the file non-editable. The app uses `utils/load-state.ts` for apply-effect conditions in the modify view. When `gridLayout.tileSize` is 0 (e.g. after reload or return from Tile Set Creator before layout runs), the apply effect uses a fallback shape from the pending restore’s `preferredTileSize` so files still become editable instead of staying on the full-screen cache. Run tests when changing load/hydration or navigation timing.
